#!/usr/bin/python

import sys
import argparse
import theano.tensor as T
import numpy as np

from cgml.io import DataReader
from cgml.optimizers import MSGD
from cgml.trainers import OnlineTrainer
from cgml.predictors import OnlinePredictor
from cgml.argparse_actions import giveArgs
from cgml.computational_graph import ComputationalGraph
from cgml.costs import nllCost

# Print outputs here
outStream = sys.stdout

# Print info here
infStream = sys.stderr

# Parsing the arguments
args = giveArgs(log = infStream)

# Open a log if needed
log = None
if args.log:
    log = open(args.log,'w')

# Data reader for training
drTrain = DataReader(args.trainData)

# Data reader for prediction
drTest  = DataReader(args.testData)

# How many input attributes
n_in = drTrain.nInputs

# Symbolic input matrix
x = T.dmatrix('x')

# Symbolic output vector
y = T.lvector('y')

# Create the model
model = ComputationalGraph(input = x,
                           cg    = args.cg,
                           log   = log)

# Write description of the model to infStream
infStream.write('\n' + str(model) + '\n')

Cost = None

if model.schema['type'] == 'classifier':
    Cost = nllCost
else:
    raise Exception('Only classification possible right now!')

# Create cost function
cost = Cost(model.dropoutOutput,y)

# Use mini-batch stochastic gradient descent to optimize parameters
# NOTE: make selectable
msgd_optimizer = MSGD(
    cost      = cost,
    params    = model.params,
    learnRate = args.learnRate)

# Create the online trainer
oTrainer = OnlineTrainer(
    x = x,
    y = y,
    cost = cost,
    optimizer = msgd_optimizer)

# Create the online predictor
oPredictor = OnlinePredictor(
    x = x,
    model = model)

infStream.write('\n')

# Start training. Loops through the training data nPasses times
for passIdx in xrange(args.nPasses):
    
    for x_train,y_train in drTrain:
        oTrainer.update(x_train,y_train)

    infStream.write('Done with pass ' + str(passIdx) +
                    ', last known training cost is ' +
                    str(oTrainer.costVec[-1]) + '\n')
        
    # After each successful pass, rewind the data reader for training
    drTrain.rewind()

infStream.write('\n')
    
# Start prediction
for x_test,y_test in drTest:
    outStream.write( '\t'.join(map(str,[y_test[0],
                                        oPredictor.predict(x_test)])) + '\n' )
    











