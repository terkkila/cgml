#!/usr/bin/python

import sys
import argparse
import theano.tensor as T
import numpy as np
import cPickle

from cgml.io import DataReader
from cgml.argparse_actions import giveArgs
from cgml.computational_graph import ComputationalGraph

# Print outputs here
outStream = sys.stdout

# Print info here
infStream = sys.stderr

# Parsing the arguments
args = giveArgs(log = infStream)

# Open a log if needed
log = ( open(args.log,'w') if args.log else None )

# Symbolic input matrix
x = T.dmatrix('x')

# Symbolic output vector
y = T.lvector('y')

if args.load:

    infStream.write('\nLoading model from file: ' + args.load + '\n')

    # Load the model
    f = open(args.load,'rb')
    model = cPickle.load(f)

else:

    # Create the model
    model = ComputationalGraph(x = x,
                               y = y,
                               cg    = args.cg,
                               log   = log,
                               learnRate = args.learnRate,
                               L1Reg = args.L1Reg,
                               L2Reg = args.L2Reg,
                               seed = args.seed)
    

# Write description of the model to infStream
infStream.write('\n' + str(model) + '\n\n')

if args.trainData:

    infStream.write("Starting to read input data for training\n")

    # Data reader for training
    drTrain = DataReader(args.trainData,
                         batchSize = args.batchSize)
    
    nBatches = 0

    nTh = 100
    
    # Start training. Loops through the training data nPasses times
    for passIdx in xrange(args.nPasses):
        
        if model.type != 'autoencoder':
        
            currMeanCost = 0.0

            n = 0

            for vals in drTrain:

                nBatches += 1
                n += 1 

                y_train = vals.take(0,axis=1)
                x_train = vals.take(xrange(1,vals.shape[1]),axis=1)

                if model.schema['type'] == 'classifier':
                    y_train = np.asarray([np.int(yi) for yi in y_train])
                    
                currMeanCost += model.supervised_update(x_train,y_train) / n

                if n % nTh == 0:
                    infStream.write('Pass ' + str(passIdx) + ', batch ' + 
                                    str(nBatches) + ', avg.cost ' + str(currMeanCost) + '\n')
                    n = 0
                    currMeanCost = 0.0

        else:

            currMeanCost = 0.0
            n = 0

            for x_train in drTrain:

                nBatches += 1
                n += 1

                currMeanCost += model.unsupervised_update(x_train) / n

                if n % nTh == 0:
                    infStream.write('Pass ' + str(passIdx) + ', batch ' + 
                                    str(nBatches) + ', avg.cost ' + str(currMeanCost) + '\n')
                    n = 0
                    currMeanCost = 0.0

        infStream.write('Done with pass ' + str(passIdx) + ':\n')

        for i in xrange(len(model.layers)):
            W,b = model.layers[i].weights()
            infStream.write(' Layer ' + str(i) + ' mean(W): ' + str(np.mean(W.flatten())) + '\n')
            infStream.write(' Layer ' + str(i) + ' mean(b): ' + str(np.mean(b.flatten())) + '\n')
        
        # After each successful pass, rewind the data reader for training
        drTrain.rewind()

infStream.write('\n')

def strMat(mat):
    return '\n'.join(' '.join(map(str,row)) for row in mat)
    
if args.testData:

    infStream.write("Starting to read data for prediction\n")
    
    # Data reader for prediction
    drTest  = DataReader(args.testData,
                         batchSize = 1)
    
    # Start prediction
    for vals in drTest:

        if model.type == 'classifier':
            
            y_test = np.asarray([np.int(yi) for yi in vals.take(0,axis=1)])
            x_test = vals.take(xrange(1,vals.shape[1]),axis=1)
            outStream.write( strMat(zip(y_test,model.predict(x_test))) + '\n' )
            
        elif model.type == 'regressor':
            
            y_test = vals.take(0,axis=1)
            x_test = vals.take(xrange(1,vals.shape[1]),axis=1)
            outStream.write( strMat(zip(y_test,model.predict(x_test))) + '\n' )
            
        elif model.type == 'autoencoder':
            
            x_test = vals
            outStream.write( strMat(model.encode(x_test)) + '\n' )


if args.save:
    
    infStream.write('Saving model to file: ' + args.save + '\n')

    f = open(args.save,'wb')
    
    cPickle.dump(model,f,protocol=cPickle.HIGHEST_PROTOCOL)










