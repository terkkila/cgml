#!/usr/bin/python

import sys
import argparse
import theano.tensor as T
import theano
import numpy as np

from cgml.io import DataReader
from cgml.optimizers import MSGD
from cgml.trainers import OnlineTrainer
from cgml.predictors import OnlinePredictor
from cgml.argparse_actions import giveArgs
from cgml.computational_graph import ComputationalGraph
#from cgml.costs import nllCost,sqerrCost

# Print outputs here
outStream = sys.stdout

# Print info here
infStream = sys.stderr

# Parsing the arguments
args = giveArgs(log = infStream)

# Open a log if needed
log = ( open(args.log,'w') if args.log else None )

# Data reader for training
drTrain = DataReader(args.trainData)

# Data reader for prediction
drTest  = DataReader(args.testData)

# How many input attributes
n_in = drTrain.nCols

# Symbolic input matrix
x = T.dmatrix('x')

# Symbolic output vector
y = T.lvector('y')

# Create the model
model = ComputationalGraph(x = x,
                           y = y,
                           cg    = args.cg,
                           log   = log)

# Write description of the model to infStream
infStream.write('\n' + str(model) + '\n\n')

if model.schema['type'] == 'classifier':

    infStream.write("Setting up the classifier:\n")

    #infStream.write("Setting up the cost function\n")

    #cost = nllCost(model.dropoutOutput,y)

    infStream.write("Setting up the optimizer\n")

    # Use mini-batch stochastic gradient descent to optimize parameters
    # NOTE: make selectable
    # NOTE: embed into OnlineTrainer
    msgd_optimizer = MSGD(
        cost      = model.supervised_cost,
        params    = model.params,
        learnRate = args.learnRate)
    
    infStream.write("Setting up the trainer\n")

    # Create the online trainer
    oTrainer = OnlineTrainer(
        x = x,
        y = y,
        cost = model.supervised_cost,
        optimizer = msgd_optimizer)

elif model.schema['type'] == 'autoencoder':

    infStream.write("Setting up the autoencoder:\n")

    #infStream.write("Setting up the cost function\n")

    #cost = sqerrCost(x,model.dropoutOutput)

    infStream.write("Setting up the optimizer\n")

    # Use mini-batch stochastic gradient descent to optimize parameters
    # NOTE: make selectable
    # NOTE: embed into OnlineTrainer
    msgd_optimizer = MSGD(
        cost      = model.unsupervised_cost,
        params    = model.params,
        learnRate = args.learnRate)
    
    infStream.write("Setting up the trainer\n")

    # Create the online trainer
    oTrainer = OnlineTrainer(
        x = x,
        y = None,
        cost = model.unsupervised_cost,
        optimizer = msgd_optimizer)
    
else:
    raise Exception('Cost function unavailable for CG schema type: ' + model.type)

infStream.write("Setting up the predictor\n")

# Create the online predictor
oPredictor = OnlinePredictor(
    x = x,
    model = model)

infStream.write('=> Done setting up the model!\n\n')
infStream.write("Starting to read input data for training\n")

# Start training. Loops through the training data nPasses times
for passIdx in xrange(args.nPasses):
    
    infStream.write("Starting training pass " + str(passIdx) + "\n")

    if model.schema['type'] != 'autoencoder':
        
        for vals in drTrain:
            y_train,x_train = [vals[0][0]],[vals[0][1:]]
            if model.schema['type'] == 'classifier':
                y_train = [np.int(yi) for yi in y_train]
            oTrainer.update(x_train,y_train)

    else:

        for x_train in drTrain:
            x_train_hat = oPredictor.predict(x_train)
            oTrainer.update(x_train,None)

    infStream.write('Done with pass ' + str(passIdx) +
                    ', last known training cost is ' +
                    str(oTrainer.costVec[-1]) + '\n')
        
    # After each successful pass, rewind the data reader for training
    drTrain.rewind()

infStream.write('\n')
    
infStream.write("Starting to read data for prediction\n")

def strMat(mat):
    return '\n'.join(' '.join(map(str,row)) for row in mat)

# Start prediction
for vals in drTest:

    if model.type == 'classifier':

        y_test = np.asarray([np.int(yi) for yi in vals.take(0,axis=1)])
        x_test = vals.take(xrange(1,vals.shape[1]),axis=1)
        outStream.write( strMat(zip(y_test,oPredictor.predict(x_test))) + '\n' )

    elif model.type == 'regressor':

        y_test = vals.take(0,axis=1)
        x_test = vals.take(xrange(1,vals.shape[1]),axis=1)
        outStream.write( strMat(zip(y_test,oPredictor.predict(x_test))) + '\n' )

    elif model.schema['type'] == 'autoencoder':

        x_test = vals
        outStream.write( strMat(oPredictor.encode(x_test)) + '\n' )

        
    











